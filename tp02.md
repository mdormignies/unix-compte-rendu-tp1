# unix-compte-rendu-tp2
Cours M. Le Cocq - TP2


# 1- Secure Shell : SSH
### 1.1 Connection ssh root (reprise fin tp-01)
Pour permettre la connexion root à distante, on tape la commande 
<pre>nano /etc/ssh/sshd_config</pre>

Et changer la ligne
<pre>PermitRootLogin yes</pre>

#### PermitRootLogin yes
Description : Permet les connexions SSH en tant qu’utilisateur root.<br>
Avantages : Accès direct et complet au système pour l’administration.<br>
Inconvénients : Augmente le risque de sécurité car le compte root est une cible privilégiée.<br>
Utilisation : À utiliser avec précaution, généralement désactivé en production pour des raisons de sécurité.<br>

#### PasswordAuthentication yes
Description : Autorise l’authentification par mot de passe.<br>
Avantages : Facilité d’utilisation sans nécessiter de gestion de clés SSH.<br>
Inconvénients : Moins sécurisé que l’authentification par clé, vulnérable aux attaques par force brute.<br>
Utilisation : Utile dans des environnements de test ou lorsque la gestion des clés est complexe. En production, il est recommandé de désactiver cette option et d’utiliser l’authentification par clé.<br>

### 1.2 Authentification par clef / Génération de clefs
Pour génerer une clé on tape 
<pre>ssh-keygen -t rsa</pre>

Pourquoi mettre une passphrase ?
<pre>Sans passphrase, si quelqu’un obtient notre clé privée, il peut accéder à nos serveurs sans restriction.</pre>

Outil utilisé ? 
<pre>ssh-keygen</pre>

Cette clef est maintenant dans le [username]/.ssh/ de notre machine hôte.

### 1.3 

Allons dans 
<pre>nano /root/.ssh/authorized_keys</pre>
Pour ajouter la clef publique de notre machine hôte dans le fichier
<hr>

Ensuite, allons dans
<pre>nano /etc/ssh/sshd_config</pre>

Et changer la ligne
<pre>PermitRootLogin yes</pre> pour <pre>PermitRootLogin prohibit-password</pre>
Et
<pre>PasswordAuthentication no</pre>

On peut maintenant se connecter grâce à notre clef publique.

### 1.4

La commande fonctionelle est :
<pre>ssh -i .ssh/maclef root@localhost -p 2222</pre>

### 1.5

Pour éviter les attaques de type brute-force ssh, c'est comme expliqué avant, on ajoute la ligne dans le sshd_config :
<pre>PermitRootLogin prohibit-password</pre>
qui permet donc de se connecter avec des clés ssh.
<hr>

Les attaques de type brute-force SSH consistent à essayer systématiquement toutes les combinaisons possibles de mots de passe pour accéder à une machine distante.

Certaines méthodes permettent de limiter le nombre d'attaques de type brute-force comme :
- Changer le port
- La double authentification
- Permettre les connexions uniquement avec des clés ssh
- etc...

# 2-Processus

#### 1.

- L'information TIME correspond au temps consommé du CPU par le processus.
- Le processus ayant le plus utulisé le processeur est :
<pre>USER         PID %CPU %MEM STAT  STARTED     TIME COMMAND
root         763  100  0.0 R+   13:20:40 00:00:00 ps</pre>

- Le premier processus lancé après le démarrage du système est : systemd.

- La commande `uptime` pemret de savoir à quelle heure la machine a été démarrée mais également le temps d'utilisation :
<pre>19:14:23 up  1:01,  2 users,  load average: 0.00, 0.00, 0.00</pre>

- Une autre commande permet de vérifier l'heure du démarrage de la machine, `who -b` : <pre>system boot  2024-10-11 18:13</pre>

- Pour connaître le nombre approximatif de processus créés depuis le démarrage de la machine, on tape la commande `grep 'processes' /proc/stat` :
<pre>processes 620</pre>

#### 2.

- Pour afficher le PPID d'un processus, on tape la commande : `ps -eo pid,ppid,comm`
<pre> PID    PPID COMMAND
      1       0 systemd
      2       0 kthreadd
      3       2 rcu_gp
      4       2 rcu_par_gp
      5       2 slub_flushwq
      6       2 netns
      8       2 kworker/0:0H-events_highpri
      9       2 kworker/u4:0-events_unbound
     10       2 mm_percpu_wq
     11       2 rcu_tasks_kthread
     12       2 rcu_tasks_rude_kthread
     13       2 rcu_tasks_trace_kthread
     14       2 ksoftirqd/0
     15       2 rcu_preempt
     16       2 migration/0</pre>

- Pour obtenir la liste ordonnée de tous les processus ancêtres de la commande ps en cours d’exécution, on tape la commande : `ps -eo pid,ppid,comm | grep -E "^\s*$$|^\s*$(ps -o ppid= -p $$)"`
<pre>580     553 sshd
    586     580 bash</pre>

#### 3. 

Pour installer pstree, j'ai d'abord essayé la commande `apt install pstree`, qui donne `E: Unable to locate package pstree`.
Et pour remédier à ce problème, la bonne commande pour l'installer est : `apt install psmisc`.

On peut maintenant l'utiliser : `pstree -p`
<pre>systemd(1)─┬─cron(480)
           ├─dbus-daemon(481)
           ├─dhclient(469)
           ├─login(545)───bash(577)
           ├─sshd(553)───sshd(580)───bash(586)───pstree(630)
           ├─systemd(570)───(sd-pam)(571)
           ├─systemd-journal(223)
           ├─systemd-logind(483)
           ├─systemd-timesyn(447)───{systemd-timesyn}(477)
           ├─systemd-udevd(250)
           └─wpa_supplicant(493)</pre>

Et pour obtenir la liste ordonnée de tous les processus ancêtres de la commande ps en cours d’exécution, on tape la commande : `pstree -ps $$ `
<pre>systemd(1)───sshd(553)───sshd(580)───bash(586)───pstree(631)</pre>

#### 4.

- Pour trier la liste des processus par occupation mémoire, on tape la commande `top` puis on appuie sur la touche M (en majuscule)
<pre> PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
      1 root      20   0  102088  12104   9128 S   0.0   0.1   0:00.72 systemd
    580 root      20   0   17996  11116   9300 S   0.0   0.1   0:00.07 sshd
    570 root      20   0   19016  10532   8852 S   0.0   0.1   0:00.05 systemd
    553 root      20   0   15432   8912   7676 S   0.0   0.1   0:00.00 sshd
    223 root      20   0   32968   8468   7376 S   0.0   0.1   0:00.10 systemd-journal
    483 root      20   0   25420   7844   6820 S   0.0   0.1   0:00.04 systemd-logind
    447 systemd+  20   0   90080   6552   5680 S   0.0   0.1   0:00.07 systemd-timesyn
    493 root      20   0   16532   5788   4928 S   0.0   0.1   0:00.04 wpa_supplicant
    250 root      20   0   26056   5704   4580 S   0.0   0.1   0:00.08 systemd-udevd
    481 message+  20   0    9248   4928   4312 S   0.0   0.0   0:00.03 dbus-daemon
    633 root      20   0   11564   4912   3036 R   0.3   0.0   0:00.02 top                                                  586 root      20   0    7992   4652   3336 S   0.0   0.0   0:00.02 bash
    577 root      20   0    7996   4636   3340 S   0.0   0.0   0:00.00 bash
    545 root      20   0    6120   3964   3444 S   0.0   0.0   0:00.06 login
    469 root      20   0    5740   3464   2640 S   0.0   0.0   0:00.00 dhclient
    571 root      20   0  103148   3100      0 S   0.0   0.0   0:00.00 (sd-pam)
    480 root      20   0    6608   2704   2456 S   0.0   0.0   0:00.01 cron
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.01 kthreadd
      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp</pre>

- Le processus le plus gourmand est `systemd` qui est responsable de l'initialisation du système au démarrage et de la gestion des processus pendant l'exécution de l'ordinateur.

- Avec la commande `top`, la touche permettant de :<br>
      - Changer la couleur : z (minuscule) affiche le tableau par la couleur choisie. Z (majuscule) permet de modifier la couleur qu'on veut afficher.<br>
      - Mettre en avant la colonne de tri : touche x<br>
      - Changer la colonne de tri : touche F<br>

- La commande htop n'est pas installée par défaut, on doit donc passer par un `apt install htop`.

##### Avantages de htop par rapport à top :
- Interface plus intuitive et interactive (colorée par défaut, navigation facile avec les touches fléchées).
- Possibilité de tuer des processus directement depuis l'interface (F9 pour tuer un processus).
- Affichage visuel de l'utilisation CPU/Mémoire pour chaque cœur du processeur.
- Utilisation simplifiée pour filtrer, trier, et manipuler les processus en temps réel.

##### Inconvénients :

- Peut être un peu plus lourd en ressources que top.
- Sur certaines machines, htop peut ne pas être installé par défaut.

# 3- Arrêt d'un processus

Pour éxecuter les deux script on doit d'abord les créer :
- Créer le fichier date.sh avec la commande : `nano date.sh`,
- Coller les lignes de codes données,
- Rendre le script éxecutable avec la commande : `chmod +x date.sh`
- Il ne reste plus qu'à l'éxecuter avec `./date.sh` :
<pre>date 20:47:45
date 20:47:46
date 20:47:47
date 20:47:48
date 20:47:49
date 20:47:51
date 20:47:52
date 20:47:53
date 20:47:54
date 20:47:55
date 20:47:56</pre>

On fait les mêmes étapes pour date-toto.sh, qui donne :
<pre>toto 15:48:48
toto 15:48:49
toto 15:48:51
toto 15:48:52
toto 15:48:53
toto 15:48:54
toto 15:48:55
toto 15:48:56
toto 15:48:58
toto 15:48:59</pre>

- Pour les mettre en arrière-plan, on fait CTRL-Z pour les suspendre et on tape la commande `bg` afin qu'elle soit en arrière-plan.
- Pour les arrêter, on tape la commande `fg` suivi du numéro donc `fg %1`.

- Pour les trouver avec ps : `ps aux | grep date.sh`
- Pour les arrêter avec kill : `kill <PID>` (Le PID est celui qu'on retrouve lorsqu'on a tapé la commadne précedente).

##### Le script date.sh :
`#!/bin/sh` : Cela indique que le script doit être exécuté avec /bin/sh, un interpréteur de commandes.<br>
`while true; do` : Une boucle infinie qui exécute continuellement les commandes suivantes.<br>
`sleep 1` : Attend 1 seconde entre chaque itération, afin de ne pas exécuter les commandes trop rapidement.<br>
`echo -n 'date '` : Affiche "date" suivi d'un espace, mais sans retour à la ligne (-n).<br>
`date +%T` : Affiche uniquement l'heure actuelle au format HH:MM:SS. L'option +%T spécifie ce format.<br>

Le script affiche la chaîne "date" suivie de l'heure actuelle chaque seconde.

##### Le script date-toto.sh :

Ce script a le même début de code jusqu'à :

`echo -n 'toto '` : Affiche "toto " sans retour à la ligne.<br>
`date --date '5 hour ago' +%T` : Utilise la commande date pour afficher l'heure 5 heures en arrière.
      L'option `--date '5 hour ago'` indique que l'heure doit être ajustée en arrière de 5 heures, et +%T spécifie le format HH:MM:SS.<br>

Ce script affiche "toto" suivi de l'heure décalée de 5 heures, et ce, chaque seconde.














