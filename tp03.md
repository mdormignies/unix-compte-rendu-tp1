# unix-compte-rendu-tp3
Cours M. Le Cocq - TP3


# Exercice paramètres

Le script que j'ai écris est le suivant 
<pre>#!/bin/bash

echo "Bonjour, vous avez rentré $# paramètres."

echo "Le nom du script est $0."

if [ $# -ge 3 ]; then
    echo "Le 3ème paramètre est $3."
else
    echo "Il n'y a pas de 3ème paramètre."
fi

echo "Voici la liste des paramètres : $@"</pre>

Pour le créer, j'ai tapé la commande `nano analyse.sh`, puis pour le lancer, `./analyse.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x analyse.sh`.

### RÉSULTAT

<pre>root@server1:~# ./analyse.sh param1 param2 param3 param4
    
Bonjour, vous avez rentré 4 paramètres.
Le nom du script est ./analyse.sh.
Le 3ème paramètre est param3.
Voici la liste des paramètres : param1 param2 param3 param4</pre>

# Exercice vérification du nombre de paramètres

Le script que j'ai écris est le suivant :

<pre>#!/bin/bash

if [ $# -ne 2 ]; then
    echo "Erreur : mettez 2 paramètres svp."
    exit 1
fi

CONCAT="$1$2"

echo "La concaténation des deux mots est : $CONCAT"</pre>

Pour le créer, j'ai tapé la commande `nano concat.sh`, puis pour le lancer, `./concat.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x concat.sh`.

### RÉSULTAT

<pre>root@server1:~# ./concat.sh youpi yay
    
La concaténation des deux mots est : youpiyay</pre>

### RÉSULTAT si erreur

<pre>root@server1:~# ./concat.sh
    
Erreur : mettez 2 paramètres svp.</pre>

# Exercice argument type et droits

Le script que j'ai écris est le suivant 
<pre>#!/bin/bash

if [ $# -ne 1 ]; then
    echo "Erreur : Vous devez passer exactement 1 fichier ou répertoire en paramètre."
    exit 1
fi

FICHIER=$1

# COMMENTAIRE : On vérifie si le fichier ou répertoire existe
if [ ! -e "$FICHIER" ]; then
    echo "Le fichier ou répertoire \"$FICHIER\" n'existe pas."
    exit 1
fi

# COMMENTAIRE : On vérifie le type du paramètre
if [ -d "$FICHIER" ]; then
    echo "Le fichier \"$FICHIER\" est un répertoire."
elif [ -f "$FICHIER" ]; then
    if [ -s "$FICHIER" ]; then
        echo "Le fichier \"$FICHIER\" est un fichier ordinaire qui n'est pas vide."
    else
        echo "Le fichier \"$FICHIER\" est un fichier ordinaire qui est vide."
    fi
else
    echo "Le fichier \"$FICHIER\" est d'un autre type (lien, périphérique, etc.)."
fi

# COMMENTAIRE : On vérifie les permissions de l'user actuel
UTILISATEUR=$(whoami)

echo -n "\"$FICHIER\" est accessible par $UTILISATEUR en "

if [ -r "$FICHIER" ]; then
    echo -n "lecture"
else
    echo -n "pas lecture"
fi

if [ -w "$FICHIER" ]; then
    echo -n ", écriture"
else
    echo -n ", pas écriture"
fi

if [ -x "$FICHIER" ]; then
    echo -n ", exécution"
else
    echo -n ", pas exécution"
fi

echo "."</pre>

Pour le créer, j'ai tapé la commande `nano test-fichier.sh`, puis pour le lancer, `./test-fichier.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x test-fichier.sh`.

### RÉSULTAT si aucun paramètre

<pre>root@server1:~# ./test-fichier.sh

Erreur : Vous devez passer exactement 1 fichier ou répertoire en paramètre.</pre>

### RÉSULTAT si fichier/répertoire inconnu

<pre>root@server1:~# ./test-fichier.sh pasdefichier.sh

Le fichier ou répertoire "pasdefichier.sh" n'existe pas.</pre>

### RÉSULTAT si fichier non vide

<pre>root@server1:~# ./test-fichier.sh analyse.sh

Le fichier "analyse.sh" est un fichier ordinaire qui n'est pas vide.
"analyse.sh" est accessible par root en lecture, écriture, exécution.</pre>

### RÉSULTAT si fichier vide

<pre>root@server1:~# ./test-fichier.sh fichiervide.sh
    
Le fichier "fichiervide.sh" est un fichier ordinaire qui est vide.
"fichiervide.sh" est accessible par root en lecture, écriture, pas exécution.</pre>

### RÉSULTAT si répertoire

<pre>root@server1:~# ./test-fichier.sh /etc
    
Le fichier "/etc" est un répertoire.
"/etc" est accessible par root en lecture, écriture, exécution.</pre>

# Exercice Afficher le contenu d’un répertoire

Le script que j'ai écris est le suivant :

<pre>#!/bin/bash

# On vérifie si un répertoire est passé en paramètre
if [ $# -ne 1 ]; then
    echo "Erreur : Vous devez passer un répertoire en paramètre."
    exit 1
fi

# Le répertoire à lister
REP=$1

# On vérifie si le paramètre est bien un répertoire
if [ ! -d "$REP" ]; then
    echo "Erreur : \"$REP\" n'est pas un répertoire ou n'existe pas."
    exit 1
fi

# On affiche les fichiers dans le répertoire
echo "####### Fichiers dans $REP/"
for fichier in "$REP"/*; do
    if [ -f "$fichier" ]; then
        echo "$fichier"
    fi
done

# On affiche les sous-répertoires dans le répertoire
echo "####### Répertoires dans $REP/"
for dossier in "$REP"/*; do
    if [ -d "$dossier" ]; then
        echo "$dossier"
    fi
done</pre>

Pour le créer, j'ai tapé la commande `nano listedir.sh`, puis pour le lancer, `./listedir.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x listedir.sh`.

### RÉSULTAT

<pre>root@server1:~# ./listedir.sh /boot

####### Fichiers dans /boot/
/boot/config-6.1.0-25-amd64
/boot/initrd.img-6.1.0-25-amd64
/boot/System.map-6.1.0-25-amd64
/boot/vmlinuz-6.1.0-25-amd64
####### Répertoires dans /boot/
/boot/grub</pre>

### RÉSULTAT si erreur

<pre>root@server1:~# ./listedir.sh salut

Erreur : "amama" n'est pas un répertoire ou n'existe pas.</pre>

### RÉSULTAT si aucun paramètre

<pre>root@server1:~# ./listedir.sh

Erreur : Vous devez passer un répertoire en paramètre.</pre>

# Exercice Lister les utilisateurs

Le problème avec `for user in $(cat /etc/passwd)` est que le fichier /etc/passwd contient des lignes avec des champs séparés par des :.
Lorsque on utilise `for user in $(cat /etc/passwd)`, cela va découper la ligne à chaque espace ou retour à la ligne, et cela peut causer des résultats inattendus,
car certaines lignes peuvent être mal interprétées.

Le script avec <strong>cut</strong> que j'ai écris est le suivant 
<pre>#!/bin/bash

echo "Utilisateurs ayant un UID supérieur à 100 :"

# <IFS=:> permet de remplacer l'ifs par : , afin de bien lire les champs séparés
while IFS=: read -r login _ uid _; do
    if [ "$uid" -gt 100 ]; then
        echo "$login"
    fi
done < /etc/passwd</pre>

Le script avec <strong>awk</strong> que j'ai écris est le suivant 
<pre>#!/bin/bash

echo "Utilisateurs ayant un UID supérieur à 100 :"
awk -F: '$3 > 100 {print $1}' /etc/passwd</pre>

Pour le créer, j'ai tapé la commande `nano listuser.sh`, puis pour le lancer, `./listuser.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x listuser.sh`.

### RÉSULTAT

<pre>root@server1:~# ./listuser.sh

Utilisateurs ayant un UID supérieur à 100 :
nobody
systemd-network
systemd-timesync
avahi-autoipd
sshd</pre>

# Exercice Mon utilisateur existe t’il

Le script que j'ai écris est le suivant 
<pre>#!/bin/bash

# Fonction pour vérifier si un utilisateur existe par login
check_by_login() {
    local login="$1"
    uid=$(grep "^$login:" /etc/passwd | cut -d: -f3)
    if [ -n "$uid" ]; then
        echo "L'utilisateur '$login' existe avec l'UID : $uid"
    else
        echo "L'utilisateur '$login' n'existe pas."
    fi
}

# Fonction pour vérifier si un utilisateur existe par UID
check_by_uid() {
    local uid="$1"
    login=$(awk -F: -v uid="$uid" '$3 == uid {print $1}' /etc/passwd)
    if [ -n "$login" ]; then
        echo "L'UID '$uid' appartient à l'utilisateur : $login"
    else
        echo "Aucun utilisateur n'a l'UID : $uid."
    fi
}

# On vérifie si des arguments sont passés
if [ $# -ne 2 ]; then
    echo "Usage : $0 <option> <login|UID>"
    echo "Options disponibles :"
    echo "  --login <login>    : Vérifie l'existence d'un utilisateur par login"
    echo "  --uid <UID>        : Vérifie l'existence d'un utilisateur par UID"
    exit 1
fi

# On vérifie selon l'option passée
case "$1" in
    --login)
        check_by_login "$2"
        ;;
    --uid)
        check_by_uid "$2"
        ;;
    *)
        echo "Option non reconnue. Utilisez --login ou --uid."
        exit 1
        ;;
esac</pre>

Pour le créer, j'ai tapé la commande `nano check-user.sh`, puis pour le lancer, `./check-user.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x check-user.sh`.

### RÉSULTAT si aucun paramètre

<pre>root@server1:~# ./check-user.sh

Usage : ./check-user.sh <option> <login|UID>
Options disponibles :
  --login <login>    : Vérifie l'existence d'un utilisateur par login
  --uid <UID>        : Vérifie l'existence d'un utilisateur par UID</pre>

### RÉSULTAT si param --login et login existant

<pre>root@server1:~# ./check-user.sh --login root
L'utilisateur 'root' existe avec l'UID : 0</pre>

### RÉSULTAT si param --login et login inexistant

<pre>root@server1:~# ./check-user.sh --login maxime
L'utilisateur 'maxime' n'existe pas.</pre>

### RÉSULTAT si param --uid et login existant

<pre>root@server1:~# ./check-user.sh --uid 1
L'UID '1' appartient à l'utilisateur : daemon</pre>

### RÉSULTAT si param --uid et login inexistant

<pre>root@server1:~# ./check-user.sh --uid 1111115
Aucun utilisateur n'a l'UID : 1111115.</pre>


