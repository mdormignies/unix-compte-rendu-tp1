# unix-compte-rendu-tp3
Cours M. Le Cocq - TP3


# Exercice paramètres

Le script que j'ai écris est le suivant 
<pre>#!/bin/bash

echo "Bonjour, vous avez rentré $# paramètres."

echo "Le nom du script est $0."

if [ $# -ge 3 ]; then
    echo "Le 3ème paramètre est $3."
else
    echo "Il n'y a pas de 3ème paramètre."
fi

echo "Voici la liste des paramètres : $@"</pre>

Pour le créer, j'ai tapé la commande `nano analyse.sh`, puis pour le lancer, `./analyse.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x analyse.sh`.

### RÉSULTAT

<pre>root@server1:~# ./analyse.sh param1 param2 param3 param4
    
Bonjour, vous avez rentré 4 paramètres.
Le nom du script est ./analyse.sh.
Le 3ème paramètre est param3.
Voici la liste des paramètres : param1 param2 param3 param4</pre>

# Exercice vérification du nombre de paramètres

Le script que j'ai écris est le suivant :

<pre>#!/bin/bash

if [ $# -ne 2 ]; then
    echo "Erreur : mettez 2 paramètres svp."
    exit 1
fi

CONCAT="$1$2"

echo "La concaténation des deux mots est : $CONCAT"</pre>

Pour le créer, j'ai tapé la commande `nano concat.sh`, puis pour le lancer, `./concat.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x concat.sh`.

### RÉSULTAT

<pre>root@server1:~# ./concat.sh youpi yay
    
La concaténation des deux mots est : youpiyay</pre>

### RÉSULTAT si erreur

<pre>root@server1:~# ./concat.sh
    
Erreur : mettez 2 paramètres svp.</pre>

# Exercice argument type et droits

Le script que j'ai écris est le suivant 
<pre>#!/bin/bash

if [ $# -ne 1 ]; then
    echo "Erreur : Vous devez passer exactement 1 fichier ou répertoire en paramètre."
    exit 1
fi

FICHIER=$1

# COMMENTAIRE : On vérifie si le fichier ou répertoire existe
if [ ! -e "$FICHIER" ]; then
    echo "Le fichier ou répertoire \"$FICHIER\" n'existe pas."
    exit 1
fi

# COMMENTAIRE : On vérifie le type du paramètre
if [ -d "$FICHIER" ]; then
    echo "Le fichier \"$FICHIER\" est un répertoire."
elif [ -f "$FICHIER" ]; then
    if [ -s "$FICHIER" ]; then
        echo "Le fichier \"$FICHIER\" est un fichier ordinaire qui n'est pas vide."
    else
        echo "Le fichier \"$FICHIER\" est un fichier ordinaire qui est vide."
    fi
else
    echo "Le fichier \"$FICHIER\" est d'un autre type (lien, périphérique, etc.)."
fi

# COMMENTAIRE : On vérifie les permissions de l'user actuel
UTILISATEUR=$(whoami)

echo -n "\"$FICHIER\" est accessible par $UTILISATEUR en "

if [ -r "$FICHIER" ]; then
    echo -n "lecture"
else
    echo -n "pas lecture"
fi

if [ -w "$FICHIER" ]; then
    echo -n ", écriture"
else
    echo -n ", pas écriture"
fi

if [ -x "$FICHIER" ]; then
    echo -n ", exécution"
else
    echo -n ", pas exécution"
fi

echo "."</pre>

Pour le créer, j'ai tapé la commande `nano test-fichier.sh`, puis pour le lancer, `./test-fichier.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x test-fichier.sh`.

### RÉSULTAT si aucun paramètre

<pre>root@server1:~# ./test-fichier.sh

Erreur : Vous devez passer exactement 1 fichier ou répertoire en paramètre.</pre>

### RÉSULTAT si fichier/répertoire inconnu

<pre>root@server1:~# ./test-fichier.sh pasdefichier.sh

Le fichier ou répertoire "pasdefichier.sh" n'existe pas.</pre>

### RÉSULTAT si fichier non vide

<pre>root@server1:~# ./test-fichier.sh analyse.sh

Le fichier "analyse.sh" est un fichier ordinaire qui n'est pas vide.
"analyse.sh" est accessible par root en lecture, écriture, exécution.</pre>

### RÉSULTAT si fichier vide

<pre>root@server1:~# ./test-fichier.sh fichiervide.sh
    
Le fichier "fichiervide.sh" est un fichier ordinaire qui est vide.
"fichiervide.sh" est accessible par root en lecture, écriture, pas exécution.</pre>

### RÉSULTAT si répertoire

<pre>root@server1:~# ./test-fichier.sh /etc
    
Le fichier "/etc" est un répertoire.
"/etc" est accessible par root en lecture, écriture, exécution.</pre>

# Exercice Afficher le contenu d’un répertoire

Le script que j'ai écris est le suivant :

<pre>#!/bin/bash

# On vérifie si un répertoire est passé en paramètre
if [ $# -ne 1 ]; then
    echo "Erreur : Vous devez passer un répertoire en paramètre."
    exit 1
fi

# Le répertoire à lister
REP=$1

# On vérifie si le paramètre est bien un répertoire
if [ ! -d "$REP" ]; then
    echo "Erreur : \"$REP\" n'est pas un répertoire ou n'existe pas."
    exit 1
fi

# On affiche les fichiers dans le répertoire
echo "####### Fichiers dans $REP/"
for fichier in "$REP"/*; do
    if [ -f "$fichier" ]; then
        echo "$fichier"
    fi
done

# On affiche les sous-répertoires dans le répertoire
echo "####### Répertoires dans $REP/"
for dossier in "$REP"/*; do
    if [ -d "$dossier" ]; then
        echo "$dossier"
    fi
done</pre>

Pour le créer, j'ai tapé la commande `nano listedir.sh`, puis pour le lancer, `./listedir.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x listedir.sh`.

### RÉSULTAT

<pre>root@server1:~# ./listedir.sh /boot

####### Fichiers dans /boot/
/boot/config-6.1.0-25-amd64
/boot/initrd.img-6.1.0-25-amd64
/boot/System.map-6.1.0-25-amd64
/boot/vmlinuz-6.1.0-25-amd64
####### Répertoires dans /boot/
/boot/grub</pre>

### RÉSULTAT si erreur

<pre>root@server1:~# ./listedir.sh salut

Erreur : "amama" n'est pas un répertoire ou n'existe pas.</pre>

### RÉSULTAT si aucun paramètre

<pre>root@server1:~# ./listedir.sh

Erreur : Vous devez passer un répertoire en paramètre.</pre>

# Exercice Lister les utilisateurs

Le problème avec `for user in $(cat /etc/passwd)` est que le fichier /etc/passwd contient des lignes avec des champs séparés par des :.
Lorsque on utilise `for user in $(cat /etc/passwd)`, cela va découper la ligne à chaque espace ou retour à la ligne, et cela peut causer des résultats inattendus,
car certaines lignes peuvent être mal interprétées.

Le script avec <strong>cut</strong> que j'ai écris est le suivant 
<pre>#!/bin/bash

echo "Utilisateurs ayant un UID supérieur à 100 :"

# <IFS=:> permet de remplacer l'ifs par : , afin de bien lire les champs séparés
while IFS=: read -r login _ uid _; do
    if [ "$uid" -gt 100 ]; then
        echo "$login"
    fi
done < /etc/passwd</pre>

Le script avec <strong>awk</strong> que j'ai écris est le suivant 
<pre>#!/bin/bash

echo "Utilisateurs ayant un UID supérieur à 100 :"
awk -F: '$3 > 100 {print $1}' /etc/passwd</pre>

Pour le créer, j'ai tapé la commande `nano listuser.sh`, puis pour le lancer, `./listuser.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x listuser.sh`.

### RÉSULTAT

<pre>root@server1:~# ./listuser.sh

Utilisateurs ayant un UID supérieur à 100 :
nobody
systemd-network
systemd-timesync
avahi-autoipd
sshd</pre>

# Exercice Mon utilisateur existe t’il

Le script que j'ai écris est le suivant 
<pre>#!/bin/bash

# Fonction pour vérifier si un utilisateur existe par login
check_by_login() {
    local login="$1"
    uid=$(grep "^$login:" /etc/passwd | cut -d: -f3)
    if [ -n "$uid" ]; then
        echo "L'utilisateur '$login' existe avec l'UID : $uid"
    else
        echo "L'utilisateur '$login' n'existe pas."
    fi
}

# Fonction pour vérifier si un utilisateur existe par UID
check_by_uid() {
    local uid="$1"
    login=$(awk -F: -v uid="$uid" '$3 == uid {print $1}' /etc/passwd)
    if [ -n "$login" ]; then
        echo "L'UID '$uid' appartient à l'utilisateur : $login"
    else
        echo "Aucun utilisateur n'a l'UID : $uid."
    fi
}

# On vérifie si des arguments sont passés
if [ $# -ne 2 ]; then
    echo "Usage : $0 <option> <login|UID>"
    echo "Options disponibles :"
    echo "  --login <login>    : Vérifie l'existence d'un utilisateur par login"
    echo "  --uid <UID>        : Vérifie l'existence d'un utilisateur par UID"
    exit 1
fi

# On vérifie selon l'option passée
case "$1" in
    --login)
        check_by_login "$2"
        ;;
    --uid)
        check_by_uid "$2"
        ;;
    *)
        echo "Option non reconnue. Utilisez --login ou --uid."
        exit 1
        ;;
esac</pre>

Pour le créer, j'ai tapé la commande `nano check-user.sh`, puis pour le lancer, `./check-user.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x check-user.sh`.

### RÉSULTAT si aucun paramètre

<pre>root@server1:~# ./check-user.sh

Usage : ./check-user.sh <option> <login|UID>
Options disponibles :
  --login <login>    : Vérifie l'existence d'un utilisateur par login
  --uid <UID>        : Vérifie l'existence d'un utilisateur par UID</pre>

### RÉSULTAT si param --login et login existant

<pre>root@server1:~# ./check-user.sh --login root
L'utilisateur 'root' existe avec l'UID : 0</pre>

### RÉSULTAT si param --login et login inexistant

<pre>root@server1:~# ./check-user.sh --login maxime
L'utilisateur 'maxime' n'existe pas.</pre>

### RÉSULTAT si param --uid et login existant

<pre>root@server1:~# ./check-user.sh --uid 1
L'UID '1' appartient à l'utilisateur : daemon</pre>

### RÉSULTAT si param --uid et login inexistant

<pre>root@server1:~# ./check-user.sh --uid 1111115
Aucun utilisateur n'a l'UID : 1111115.</pre>

# Exercice Création d'un utilisateur

Le script que j'ai écris est le suivant :

<pre>#!/bin/bash

# Fonction pour vérifier si l'utilisateur est root
check_if_root() {
    if [ "$USER" != "root" ]; then
        echo "Erreur : Ce script doit être exécuté en tant que root."
        exit 1
    fi
}

# Fonction pour vérifier l'existence de l'utilisateur
check_user_existence() {
    local login="$1"
    if id "$login" &>/dev/null; then
        echo "L'utilisateur '$login' existe déjà."
        exit 1
    fi
}

# Fonction pour vérifier l'existence du répertoire /home/$login
check_home_directory() {
    local home_dir="/home/$1"
    if [ -d "$home_dir" ]; then
        echo "Le répertoire $home_dir existe déjà."
        exit 1
    fi
}

create_user() {
    local login="$1"
    local uid="$2"
    local gid="$3"
    local comment="$4"
    local home_dir="/home/$login"

    # Création de l'utilisateur avec useradd
    useradd -m -d "$home_dir" -u "$uid" -g "$gid" -c "$comment" "$login"

    # On vérifie si la création a réussi
    if [ $? -eq 0 ]; then
        echo "L'utilisateur $login a été créé avec succès."
        echo "Le répertoire $home_dir a été créé."
    else
        echo "Erreur lors de la création de l'utilisateur."
    fi
}

# On vérifie si l'utilisateur actuel est root
check_if_root

# Lecture des informations pour le nouvel utilisateur
echo "Veuillez entrer les informations pour le nouvel utilisateur :"

# On demande le login
read -p "Login : " login

# On vérifie l'existence de l'utilisateur
check_user_existence "$login"

# On vérifie l'existence du répertoire /home/$login
check_home_directory "$login"

# On demande les autres informations
read -p "Nom : " nom
read -p "Prénom : " prenom
read -p "UID : " uid
read -p "GID : " gid
read -p "Commentaires (description) : " comments

# Concatenation du commentaire avec le nom complet
comment="$prenom $nom, $comments"

# On crée l'utilisateur
create_user "$login" "$uid" "$gid" "$comment"</pre>

Pour le créer, j'ai tapé la commande `nano create-user.sh`, puis pour le lancer, `./create-user.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x create-user.sh`.

### RÉSULTAT si login déjà existant

<pre>root@server1:~# ./create-user.sh

Veuillez entrer les informations pour le nouvel utilisateur :
Login : root
L'utilisateur 'root' existe déjà.</pre>

### RÉSULTAT

<pre>root@server1:~# ./create-user.sh

Veuillez entrer les informations pour le nouvel utilisateur :
Login : maxime
Nom : dor
Prénom : maxime
UID : 1003
GID : 2
Commentaires (description) : salut
L'utilisateur maxime a été créé avec succès.</pre>

On peut vérifier avec `ls /home` si le login `maxime` a bien été crée :

<pre>root@server1:~# ls /home
maxime</pre>

# Exercice Lecture au clavier

Le script que j'ai écris est le suivant :

<pre>#!/bin/bash

# On vérifie que le répertoire est bien spécifié en argument
if [ $# -ne 1 ]; then
    echo "Usage: $0 <directory>"
    exit 1
fi

# On vérifie que l'argument est un répertoire valide
if [ ! -d "$1" ]; then
    echo "Erreur : $1 n'est pas un répertoire valide."
    exit 1
fi

# On parcourt chaque fichier dans le répertoire
for file in "$1"/*; do
    # On utilise la commande file pour vérifier si c'est un fichier texte
    if file "$file" | grep -q "text"; then
        # On demande à l'utilisateur s'il souhaite visualiser le fichier
        echo -n "Voulez-vous visualiser le fichier $file ? (y/n) : "
        read answer

        # Si la réponse est "oui", on affiche le fichier avec less
        if [ "$answer" = "y" ]; then
            less "$file"
        fi
    fi
done</pre>

Pour le créer, j'ai tapé la commande `nano view-files.sh`, puis pour le lancer, `./view-files.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x view-files.sh`.

### RÉSULTAT

<pre>root@server1:~# ./view-files.sh /etc/ssh
Voulez-vous visualiser le fichier /etc/ssh/moduli ? (y/n) : n
Voulez-vous visualiser le fichier /etc/ssh/ssh_config ? (y/n) : n
Voulez-vous visualiser le fichier /etc/ssh/sshd_config ? (y/n) : y</pre>

On affiche donc le fichier sshd_config à l'utilisateur.

### QUESTIONS
- Comment quitter `more` ? touche q
- Pour avancer d'une ligne ? touche Enter
- Pour reculer d'une ligne ? touche Espace
- Pour remonter d'une page ? Il faut `less` et c'est touche b
- Pour chercher une chaîne de caractères ? Il faut `less` et c'est touche / suivi du texte
- Passer à l'occurence suivant ? touche n

# Exercice appréciation

Le script que j'ai écris est le suivant :

<pre>#!/bin/bash

# Boucle infinie pour demander des notes jusqu'à ce que l'utilisateur appuie sur 'q'
while true; do
    # On demande à l'utilisateur de saisir une note ou de quitter avec 'q'
    echo -n "Veuillez saisir une note (ou appuyer sur 'q' pour quitter) : "
    read input

    # On vérifie si l'utilisateur a appuyé sur 'q' pour quitter
    if [ "$input" = "q" ]; then
        echo "Vous avez quitté le programme."
        break
    fi

    # On vérifie si l'entrée est un nombre valide
    if ! [[ "$input" =~ ^[0-9]+$ ]]; then
        echo "Veuillez entrer un nombre valide."
        continue
    fi

    # On convertit l'entrée en nombre
    note=$input
    
    # On affiche un message en fonction de la note
    if [ "$note" -ge 16 ] && [ "$note" -le 20 ]; then
        echo "Très bien"
    elif [ "$note" -ge 14 ] && [ "$note" -lt 16 ]; then
        echo "Bien"
    elif [ "$note" -ge 12 ] && [ "$note" -lt 14 ]; then
        echo "Assez bien"
    elif [ "$note" -ge 10 ] && [ "$note" -lt 12 ]; then
        echo "Moyen"
    elif [ "$note" -lt 10 ]; then
        echo "Insuffisant"
    else
        echo "Note hors de portée. Entrez une note entre 0 et 20."
    fi
done</pre>

Pour le créer, j'ai tapé la commande `nano note.sh`, puis pour le lancer, `./note.sh`.<br>
CEPENDANT, pour l'éxécuter il nous faut des droits d'accès. J'ai donc tapé la commande `chmod +x note.sh`.

## RÉSULTAT

<pre>root@server1:~# ./note.sh

Veuillez saisir une note (ou appuyer sur 'q' pour quitter) : 3
Insuffisant
Veuillez saisir une note (ou appuyer sur 'q' pour quitter) : 5
Insuffisant
Veuillez saisir une note (ou appuyer sur 'q' pour quitter) : 8
Insuffisant
Veuillez saisir une note (ou appuyer sur 'q' pour quitter) : 10
Moyen
Veuillez saisir une note (ou appuyer sur 'q' pour quitter) : 15
Bien
Veuillez saisir une note (ou appuyer sur 'q' pour quitter) : 20
Très bien
Veuillez saisir une note (ou appuyer sur 'q' pour quitter) : 22
Note hors de portée. Entrez une note entre 0 et 20.
Veuillez saisir une note (ou appuyer sur 'q' pour quitter) : q
Vous avez quitté le programme.</pre>

Merci Monsieur !


